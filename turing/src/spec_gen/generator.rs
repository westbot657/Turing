use std::collections::HashMap;
use std::fs;
use std::path::Path;
use rustc_hash::FxHashMap;
use crate::engine::types::ScriptFnMetadata;

use anyhow::{Result, anyhow};
use convert_case::{Case, Casing};
use crate::interop::params::DataType;
use crate::interop::types::Semver;

/// This places txt files in the `output_folder` titled as `<capability>.txt`
pub fn generate_specs(
    metadata: &FxHashMap<String, ScriptFnMetadata>,
    api_versions: &HashMap<String, Semver>,
    output_directory: &Path,
) -> Result<()> {
    if !output_directory.exists() {
        return Err(anyhow!("output directory must exist"))
    }
    if !output_directory.is_dir() {
        return Err(anyhow!("output directory must be a directory, not a file"))
    }

    let mut output = Vec::new();

    for (api, ver) in api_versions {
        output.push((api.clone(), generate_spec(api, *ver, metadata)?))
    }

    for (name, contents) in output {
        let path = output_directory.join(format!("{}.txt", name));
        fs::write(path, contents)?;
    }

    Ok(())
}

fn generate_spec(api: &str, ver: Semver, metadata: &FxHashMap<String, ScriptFnMetadata>) -> Result<String> {
    let mut spec = String::new();

    spec += &format!("#api {}\n", api);
    spec += &format!("#version {}\n\n", ver);

    spec += r#"
// This file was generated by Turing.rs, it is used to generate API bindings for all supported languages.
// Please DO NOT modify this file unless you know what you are doing.

"#;

    let mut globals = Vec::new();
    let mut classes = HashMap::new();

    for (name, data) in metadata {
        if data.capability != api { continue };
        if name.contains(".") {
            let class_name = name.splitn(2, "::").collect::<Vec<&str>>()[0];
            if !classes.contains_key(class_name) {
                classes.insert(class_name.to_string(), (true, Vec::new()));
            }
            let (is_opaque, map) = classes.get_mut(class_name).unwrap();
            *is_opaque = true;
            map.push(data.signature.clone())
        } else if name.contains("::") {
            let class_name = name.splitn(2, "::").collect::<Vec<&str>>()[0].to_case(Case::Pascal);
            if !classes.contains_key(&class_name) {
                classes.insert(class_name.to_string(), (false, Vec::new()));
            }
            let (_, map) = classes.get_mut(&class_name).unwrap();
            map.push(data.signature.clone())
        } else {
            globals.push(data.signature.clone())
        }
    }

    if !globals.is_empty() {
        spec += ":Global:\n";

        for part in globals {
            spec += &part;
            spec += "\n";
        }

    }

    for (class, (is_opaque, functions)) in classes {
        spec += ":";
        spec += &class;
        if is_opaque {
            spec += " [opaque] "
        }
        spec += ":\n";
        spec += &functions.join("\n");
        spec += "\n";
    }

    Ok(spec)
}

impl ScriptFnMetadata {
    fn spec_signature(&self, class_name: &str, func_name: &str) -> String {
        let mut s = "(".to_string();
        s += &self.param_types.iter().map(|d| d.as_rust_param_type(class_name)).collect::<Vec<&str>>().join(", ");
        s += ")";

        if let Some(r) = self.return_type.get(0) {
            s += " -> ";
            s += r.as_rust_param_type(class_name);
        }

        s += " : _";
        if class_name != "" {
            s += &class_name.to_case(Case::Snake);
            s += "_";
        }
        s += &func_name.to_case(Case::Snake);

        if let Some(doc) = &self.doc_comment {
            s += "\n-- ";
            s += &doc.replace("\\n", "\n").replace("\n", "\n-- ")
        }

        s
    }
}

impl DataType {
    fn as_rust_param_type<'a>(&self, class_name: &'a str) -> &'a str {
        match self {
            DataType::I8 => "i8",
            DataType::I16 => "i16",
            DataType::I32 => "i32",
            DataType::I64 => "i64",
            DataType::U8 => "u8",
            DataType::U16 => "u16",
            DataType::U32 => "u32",
            DataType::U64 => "u64",
            DataType::F32 => "f32",
            DataType::F64 => "f64",
            DataType::Bool => "bool",
            DataType::RustString => "&str",
            DataType::ExtString => "&str",
            DataType::Object => class_name,
            DataType::RustError => unreachable!("RustError"),
            DataType::ExtError => unreachable!("ExtError"),
            DataType::Void => "()",
            DataType::Vec2 => "Vec2",
            DataType::Vec3 => "Vec3",
            DataType::RustVec4 => "Vec4",
            DataType::ExtVec4 => "Vec4",
            DataType::RustQuat => "Quat",
            DataType::ExtQuat => "Quat",
            DataType::RustMat4 => "Mat4",
            DataType::ExtMat4 => "Mat4",
        }
    }
}

#[cfg(test)]
mod generator_tests {
    use std::collections::HashMap;
    use anyhow::Result;
    use serde_json::json;
    use crate::engine::types::ScriptFnMetadata;

    #[test]
    fn test_generator_turing() -> Result<()> {

        // let script_fns: HashMap<String, ScriptFnMetadata> = json!({
        //     "test_function": {
        //         "capability": "test",
        //         "param_types": [],
        //         "return_types": [],
        //         "signature": "",
        //         "doc_comment": ""
        //     }
        // }).into();

        Ok(())
    }

}

