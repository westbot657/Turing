use std::collections::HashMap;
use std::fs;
use std::path::Path;
use rustc_hash::FxHashMap;
use crate::engine::types::ScriptFnMetadata;

use anyhow::{Result, anyhow};
use convert_case::{Case, Casing};
use crate::interop::types::Semver;

/// This places txt files in the `output_folder` titled as `<capability>.txt`
pub fn generate_specs(
    metadata: &FxHashMap<String, ScriptFnMetadata>,
    api_versions: &HashMap<String, Semver>,
    output_directory: &Path,
) -> Result<()> {

    if !output_directory.exists() {
        return Err(anyhow!("output directory must exist"))
    }
    if !output_directory.is_dir() {
        return Err(anyhow!("output directory must be a directory, not a file"))
    }

    let mut output = Vec::new();

    // always generate core spec
    for (api, ver) in api_versions {
        output.push((api.clone(), generate_spec(api, *ver, metadata)?))
    }
    

    for (name, contents) in output {
        let path = output_directory.join(format!("{}.txt", name));
        fs::write(path, contents)?;
    }

    Ok(())
}

fn generate_spec(api: &str, ver: Semver, metadata: &FxHashMap<String, ScriptFnMetadata>) -> Result<String> {
    let mut spec = String::new();

    spec += &format!("#api {}\n", api);
    spec += &format!("#version {}\n\n", ver);

    spec += r#"
// This file was generated by Turing.rs, it is used to generate API bindings for all supported languages.
// Please DO NOT modify this file unless you know what you are doing.

"#;

    let mut globals = Vec::new();
    let mut classes = HashMap::new();

    for (name, data) in metadata {
        if data.capability != api { continue };
        
        if name.contains(".") { // methods
            let names = name.splitn(2, ".").collect::<Vec<&str>>();
            let class_name = names[0].to_case(Case::Pascal);
            let func_name = names[1].to_case(Case::Snake);
            if !classes.contains_key(&class_name) {
                classes.insert(class_name.to_string(), (true, Vec::new()));
            }
            let (is_opaque, map) = classes.get_mut(&class_name).unwrap();
            *is_opaque = true;
            map.push(data.generate_signature(Some(&class_name), &func_name, FnType::Method))
        } else if name.contains("::") { // functions
            let names = name.splitn(2, "::").collect::<Vec<&str>>();
            let class_name = names[0].to_case(Case::Pascal);
            let func_name = names[1].to_case(Case::Snake);
            if !classes.contains_key(&class_name) {
                classes.insert(class_name.to_string(), (false, Vec::new()));
            }
            let (_, map) = classes.get_mut(&class_name).unwrap();
            map.push(data.generate_signature(Some(&class_name), &func_name, FnType::Function))
        } else { // globals
            globals.push(data.generate_signature(None, name, FnType::Global))
        }
    }

    if !globals.is_empty() {
        spec += ":Global:\n";

        for part in globals {
            spec += &part;
            spec += "\n";
        }

    }

    for (class, (is_opaque, functions)) in classes {
        spec += ":";
        spec += &class;
        if is_opaque {
            spec += " [opaque] "
        }
        spec += ":\n";
        spec += &functions.join("\n");
        spec += "\n";
    }

    Ok(spec)
}

enum FnType {
    Method,
    Function,
    Global,
}

impl ScriptFnMetadata {
    fn generate_signature(&self, class_name: Option<&str>, func_name: &str, ty: FnType) -> String {
        let mut out = String::new();

        let binding = "_".to_string()
            + &if let Some(cn) = class_name { cn.to_case(Case::Snake) + "__" } else { String::new() }
            + &func_name.to_case(Case::Snake);

        if matches!(ty, FnType::Function) {
            out += "::";
        }

        out += func_name;

        out += "(";

        out += &self.param_types.iter().map(|info | format!("{}: {}", info.name, info.data_type_name)).collect::<Vec<String>>().join(", ");

        out += ") -> ";

        out += self.return_type.first().map_or("void", |v| &v.1);

        out += " : ";
        out += &binding;

        out
    }
}


#[cfg(test)]
mod generator_tests {
    use anyhow::Result;

    #[test]
    fn test_generator_turing() -> Result<()> {



        Ok(())
    }

}

