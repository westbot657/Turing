use crate::{engine::types::ScriptFnMetadata, spec_gen::json_generator};
use rustc_hash::FxHashMap;
use std::collections::HashMap;
use std::fs;
use std::path::Path;

use crate::interop::types::Semver;
use anyhow::{Result, anyhow};
use convert_case::{Case, Casing};

/// This places txt files in the `output_folder` titled as `<capability>.txt`
pub fn generate_specs(
    metadata: &FxHashMap<String, ScriptFnMetadata>,
    api_versions: &FxHashMap<String, Semver>,
    output_directory: &Path,
) -> Result<()> {
    if !output_directory.exists() {
        return Err(anyhow!("output directory must exist"));
    }
    if !output_directory.is_dir() {
        return Err(anyhow!("output directory must be a directory, not a file"));
    }

    let mut output = Vec::new();

    // always generate core spec
    for (api, ver) in api_versions {
        output.push((api.clone(), generate_spec(api, *ver, metadata)?))
    }

    for (name, contents) in output {
        let path = output_directory.join(format!("{}.txt", name));
        fs::write(path, contents)?;
    }

    let json = json_generator::generate_specs_json(metadata, api_versions)?;

    let json_path = output_directory.join("specs.json");
    let json_contents = serde_json::to_string_pretty(&json)?;
    fs::write(json_path, json_contents)?;

    Ok(())
}

fn generate_spec(
    api: &str,
    ver: Semver,
    metadata: &FxHashMap<String, ScriptFnMetadata>,
) -> Result<String> {
    let mut spec = String::new();

    spec += &format!("#api {}\n", api);
    spec += &format!("#version {}\n\n", ver);

    spec += r#"
// This file was generated by Turing.rs, it is used to generate API bindings for all supported languages.
// Please DO NOT modify this file unless you know what you are doing.

"#;

    let mut globals = Vec::new();
    let mut classes = HashMap::new();

    for (name, data) in metadata {
        if data.capability != api {
            continue;
        };

        if name.contains(ScriptFnMetadata::METHOD_SEPARATOR) {
            // methods
            let names = name.splitn(2, ScriptFnMetadata::METHOD_SEPARATOR).collect::<Vec<&str>>();
            let class_name = names[0].to_case(Case::Pascal);
            let func_name = names[1].to_case(Case::Snake);
            if !classes.contains_key(&class_name) {
                classes.insert(class_name.to_string(), Vec::new());
            }
            let map = classes.get_mut(&class_name).unwrap();
            map.push(data.generate_signature(
                &func_name,
                FnType::Method,
                &data.as_internal_name(name),
            ))
        } else if name.contains(ScriptFnMetadata::STATIC_SEPARATOR) {
            // functions
            let names = name.splitn(2, ScriptFnMetadata::STATIC_SEPARATOR).collect::<Vec<&str>>();
            let class_name = names[0].to_case(Case::Pascal);
            let func_name = names[1].to_case(Case::Snake);
            if !classes.contains_key(&class_name) {
                classes.insert(class_name.to_string(), Vec::new());
            }
            let map = classes.get_mut(&class_name).unwrap();
            map.push(data.generate_signature(
                &func_name,
                FnType::Function,
                &data.as_internal_name(name),
            ))
        } else {
            // globals
            globals.push(data.generate_signature(
                name,
                FnType::Global,
                &data.as_internal_name(name),
            ))
        }
    }

    if !globals.is_empty() {
        spec += "[Global]\n";

        for part in globals {
            spec += &part;
            spec += "\n";
        }
    }

    for (class, functions) in classes {
        spec += &format!("[{class}]\n{}\n", functions.join("\n"));
    }

    Ok(spec)
}

enum FnType {
    Method,
    Function,
    Global,
}

impl ScriptFnMetadata {
    fn generate_signature(&self, func_name: &str, ty: FnType, binding: &str) -> String {
        let mut out = String::new();

        if matches!(ty, FnType::Function) {
            out += "::";
        }

        out += func_name;

        out += "(";

        let invalid_patterns = [
            "`", "'", "\"", "<", ">", ":", ".", ",", "/", "?", "!", "%", "$", "#", "-", "+", "=",
            "|", "[", "]", "{", "}",
        ];

        out += &self.param_types
            .iter()
            .map(|info| {
                let mut tn = info.data_type_name.clone();
                if invalid_patterns.iter().any(|p| tn.contains(p)) {
                    let tn_old = tn.clone();
                    for p in invalid_patterns {
                        tn = tn.replace(p, "");
                    }
                    eprintln!("[API Generator Warning]: type name \"{tn_old}\" contains invalid characters and should be manually sanitized to avoid potential naming conflicts, using name \"{tn}\" instead");
                }
                format!("{}: {}", info.name, tn)
            })
            .collect::<Vec<String>>()
            .join(", ");

        out += ") -> ";

        out += self.return_type.first().map_or("void", |v| &v.1);

        out += " : ";
        out += binding;

        out
    }
}

#[cfg(test)]
mod generator_tests {
    use anyhow::Result;

    #[test]
    fn test_generator_turing() -> Result<()> {
        Ok(())
    }
}
